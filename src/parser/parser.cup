package compiler.syntax;

import compiler.settings.*;
import java_cup.runtime.*;


parser code {:
	
:}


//NON TERMINALS
non terminal S, EnvironmentFile, Meta, Interface, Step, Actions;
non terminal ParticipantFiles, ParticipantFile;
non terminal SimulationFile, EnvironmentConfig, ParticipantConfigList, ParticipantConfigs, ParticipantConfig, End;
non terminal Environmental_vars, Participant_vars, AttributeDeclaration, AttributeDeclarationList;
non terminal Block, Action, ArgList, Arg, DataType;
non terminal AssignmentList, Assignment;
non terminal Lines, Statement, BooleanExpression, NumericalExpression;
non terminal IfStatement, ElseStatement, Declaration, Constraint, ArithmeticExpression;
non terminal IdList;
non terminal FunctionCall, NumericalExpressionList, SystemPartRef, SystemVar, SystemVarName, Index;
non terminal OrExpression, AndExpression, RelationalExpression, EqualityExpression, AdditiveExpression;
non terminal MultiplicativeExpression, UnaryExpression, Data;


//TERMINALS

terminal NAME, ENVIRONMENT, PARTICIPANT, PART,		//Keywords
		 SIMULATION, GLOBAL, STEP, ACTION, END,
		 IF, ELSE, WHILE, RETURN, INT, FLOAT, ATTRIBUTES,
		 DEF, REQUIRED;
		 
terminal NUM_STEPS, NUM_PARTS, NUM_ACTIONS,			//System Variables
		 RANDI, RANDF, ME;  				

terminal STRING, NUMBER, DECIMAL, ID;				//Constants

terminal LBRC, RBRC, SEMI, LPREN, RPREN, COMMA,		//Punctuation	
		 TIMESEQ, DIVIDEEQ, MINUSEQ, PLUSEQ, MODEQ, 
		 EQ, DOLLAR, LSBRK, RSBRK, DOT, LTEQ, GTEQ, 
		 PLUS, MINUS, TIMES, DIVIDE, MOD, EQEQ, NOTEQ, 
		 AND, OR, LT, GT, NOT;

//solves the if-else ambiguity
precedence left ELSE;

//////////////////////
//GRAMMAR
//////////////////////
start with S;

//Simulation Level
S ::= SimulationFile:s EnvironmentFile:ef ParticipantFiles:pf
																{: ASTNode n = new ASTNode(s); 
																   n.pushOp(ef);
																   n.pushOp(pf);
																   RESULT = n;
																:}; 

EnvironmentFile ::= ENVIRONMENT Meta:m Interface:i Step:s Actions:a 
																{: ASTNode n = new ASTNode(sym.ENVIRONMENT); 
																   n.pushOp(m);
																   n.pushOp(i);
																   n.pushOp(s);
																   n.pushOp(a);
																   RESULT = n;
																:}; 

ParticipantFile ::= PARTICIPANT Meta:m Step:s
																{: ASTNode n = new ASTNode(sym.PARTICIPANT); 
																   n.pushOp(m);
																   n.pushOp(s);
																   RESULT = n;
																:}; 
																
ParticipantFiles ::= ParticipantFile:p ParticipantFiles:pf  
																{: ASTNode n = new ASTNode(null); 
																   n.pushOp(p);
																   n.pushOp(pf);
																   RESULT = n;
																:} 
					| /*empty*/;
					
					
					
					
SimulationFile ::= SIMULATION Meta:m EnvironmentConfig:ec ParticipantConfigList:ecl End 
																{: ASTNode n = new ASTNode(sym.SIMULATION); 
																		   n.pushOp(m);
																		   n.pushOp(ec);
																		   n.pushOp(ecl);
																		   RESULT = n;
																System.out.println("Parsed simulation file: " + m); 
																:};


//===========================================================================
//File Level
Meta ::= NAME STRING:s SEMI {: RESULT = s; :};
Interface ::= Environmental_vars Participant_vars;
Environmental_vars ::= GLOBAL LBRC AttributeDeclarationList RBRC | /* empty */;
Participant_vars ::= ATTRIBUTES LBRC AttributeDeclarationList RBRC | /* empty */;


//Environment and Participant File Specific
Step ::= DEF REQUIRED STEP LPREN RPREN Block;
Actions ::= Action Actions | /*empty*/;
Action ::= DEF ACTION ID LPREN ArgList RPREN Block
		 | DEF ACTION ID LPREN RPREN Block;

ArgList ::= Arg COMMA ArgList | Arg;
Arg ::= DataType ID;

//Simulation File Specific
EnvironmentConfig ::= ENVIRONMENT STRING:s LBRC AssignmentList RBRC {: Yylex.files.addFirst((String)s); :};

ParticipantConfigList ::= ParticipantConfigs | /* empty */;

ParticipantConfigs ::= ParticipantConfig ParticipantConfigs
                    | ParticipantConfig;

ParticipantConfig ::= PARTICIPANT STRING:s ID LBRC AssignmentList RBRC {: Yylex.files.addLast((String)s); :}
                   | PARTICIPANT STRING:s ID {: Yylex.files.addLast((String)s); :} SEMI;

AssignmentList ::= Assignment SEMI AssignmentList | /*empty*/;

End ::= DEF REQUIRED END LPREN RPREN Block;

//===========================================================================
//Block Level

Block ::= LBRC Lines RBRC;

Lines ::= Statement Lines
       | /*empty*/;

Statement ::= Block
           | IfStatement 
           | ElseStatement
           | WHILE LPREN BooleanExpression RPREN Statement
           | RETURN NumericalExpression SEMI
           | NumericalExpression SEMI
           | Declaration SEMI;
           
IfStatement ::= IF LPREN BooleanExpression RPREN Statement;
ElseStatement ::= IF LPREN BooleanExpression RPREN Statement ELSE Statement;

//DECLARATIONS
AttributeDeclarationList ::= AttributeDeclaration SEMI AttributeDeclarationList | /*empty*/;
AttributeDeclaration ::= Declaration Constraint | Declaration;

Constraint ::= LBRC ArithmeticExpression RBRC;

Declaration ::= DataType IdList;

IdList ::= ID COMMA IdList | ID;

DataType ::= INT | FLOAT; 

//ASSIGNMENT
Assignment ::= ID TIMESEQ NumericalExpression
            | ID DIVIDEEQ NumericalExpression
            | ID MINUSEQ NumericalExpression
            | ID PLUSEQ NumericalExpression
            | ID MODEQ NumericalExpression
            | ID EQ NumericalExpression;

//FUNCTION CALLS
FunctionCall ::= ID LPREN NumericalExpressionList RPREN  
				| ID LPREN RPREN  
				| DOLLAR SystemPartRef DOT STEP LPREN NumericalExpressionList RPREN
				| DOLLAR SystemPartRef DOT STEP LPREN RPREN  
				| DOLLAR ACTION LSBRK Index RSBRK LPREN NumericalExpressionList RPREN 
				| DOLLAR ACTION LSBRK Index RSBRK LPREN RPREN;

NumericalExpressionList ::= NumericalExpression COMMA NumericalExpressionList | NumericalExpression;

//EXPRESSIONS	
BooleanExpression ::= OrExpression;

OrExpression ::= OrExpression OR AndExpression
    | AndExpression;

AndExpression ::= AndExpression AND EqualityExpression 
      			| EqualityExpression;

EqualityExpression ::= EqualityExpression EQEQ RelationalExpression
                   | EqualityExpression NOTEQ RelationalExpression
                   | RelationalExpression;

RelationalExpression ::= RelationalExpression LT AdditiveExpression
                      | RelationalExpression GT AdditiveExpression
                      | RelationalExpression LTEQ AdditiveExpression
                      | RelationalExpression GTEQ AdditiveExpression
                      | Data
                      | LPREN NumericalExpression RPREN;

NumericalExpression ::= Assignment
            | ArithmeticExpression;

ArithmeticExpression ::= AdditiveExpression;

AdditiveExpression ::= AdditiveExpression PLUS MultiplicativeExpression
                   | AdditiveExpression MINUS MultiplicativeExpression
                   | MultiplicativeExpression;

MultiplicativeExpression ::= MultiplicativeExpression TIMES UnaryExpression
                         |  MultiplicativeExpression DIVIDE UnaryExpression
                         |  MultiplicativeExpression MOD UnaryExpression
                         | UnaryExpression;

UnaryExpression ::= NOT UnaryExpression
                | LPREN NumericalExpression RPREN 
                | Data;

//VARIABLES AND DATA
Data ::= ID | SystemVar | NUMBER | DECIMAL | FunctionCall;

SystemVar ::= DOLLAR SystemVarName | DOLLAR SystemPartRef DOT ID | DOLLAR GLOBAL DOT ID;

SystemVarName ::= NUM_STEPS
        |    NUM_PARTS
        |    NUM_ACTIONS
        |    RANDI
        |    RANDF;

SystemPartRef ::= PART LSBRK Index RSBRK | ME;

Index ::= ID | NUMBER;